import { WalletBase } from './base.js';
import {
  BrowserProvider,
  Transaction,
  hexlify,
  type TransactionRequest,
  type Eip1193Provider,
} from 'ethers';

declare global {
  // Expose the injected provider placed on the window object by MetaMask.
  // We type it as unknown because the exact shape is library-specific and we
  // interact with it exclusively through ethers' BrowserProvider wrapper.
  interface Window {
    ethereum?: unknown;
  }
}

/**
 * Wallet integration for the MetaMask browser extension.
 *
 * It fulfils the minimal `WalletBase` contract (fetching the current address
 * and signing arbitrary messages). MetaMask **cannot** sign a raw transaction
 * without also broadcasting it, therefore {@link signTxn} intentionally throws
 * and consumers should use {@link sendTransaction} instead.
 */
export class MetamaskWallet extends WalletBase {
  private constructor(private readonly provider: BrowserProvider) {
    super();
  }

  /**
   * Request connection to MetaMask and create a new `MetamaskWallet`.
   *
   * Internally this triggers the extension UI via `eth_requestAccounts` which
   * asks the user to authorise account access.
   *
   * @throws If no injected provider is found (MetaMask not installed).
   */
  public static async connect(): Promise<MetamaskWallet> {
    if (typeof window.ethereum === 'undefined') {
      throw new Error('Metamask provider not found. Please install Metamask.');
    }

    const provider = new BrowserProvider(window.ethereum as Eip1193Provider);
    // Prompt the user to connect (select account)
    await provider.send('eth_requestAccounts', []);
    return new MetamaskWallet(provider);
  }

  /** @inheritdoc */
  public async getAddress(): Promise<string> {
    const signer = await this.provider.getSigner();
    return signer.getAddress();
  }

  /**
   * Sign **and send** a transaction through MetaMask and return the signature.
   *
   * MetaMask cannot produce a detached signature; it always broadcasts the
   * transaction after signing. This implementation hides that detail from
   * consumers by performing the send internally and returning the raw
   * signature so that the method still fulfils the `WalletBase` contract.
   *
   * @param tx - RLP-encoded unsigned transaction as `Uint8Array`.
   * @returns   The hex-encoded signature generated by MetaMask.
   */
  public async signTxn(tx: Uint8Array): Promise<string> {
    const signer = await this.provider.getSigner();

    // Convert raw bytes into a transaction object MetaMask can understand
    const hexTx = hexlify(tx);
    const parsed = Transaction.from(hexTx);

    // Build a TransactionRequest but **only** include fields that have
    // meaningful, non-default values. Omitting `nonce`, `gasPrice`, `chainId`,
    // etc. lets MetaMask fill them in automatically.
    const txRequest: Partial<TransactionRequest> = { value: parsed.value };
    if (parsed.to) txRequest.to = parsed.to;
    if (parsed.data && parsed.data !== '0x') txRequest.data = parsed.data;
    if (parsed.gasLimit && parsed.gasLimit !== 0n) txRequest.gasLimit = parsed.gasLimit;
    // nonce / gasPrice / chainId intentionally omitted so MetaMask fills them

    const response = await signer.sendTransaction(txRequest);
    const sig = response.signature;
    if (!sig) {
      throw new Error('MetaMask did not return a signature');
    }
    return typeof sig === 'string' ? sig : sig.serialized;
  }

  /** @inheritdoc */
  public async signMessage(msg: Uint8Array | string): Promise<string> {
    const signer = await this.provider.getSigner();
    return signer.signMessage(msg);
  }
}
