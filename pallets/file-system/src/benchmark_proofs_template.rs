//! Autogenerated proof cases for benchmarking `pallet_file_system`.
//!
//! THIS FILE WAS AUTO-GENERATED USING THE `generateFileSystemBenchmarkProofs.ts` SCRIPT FROM STORAGE HUB.
//! DATE: {{date}}.
//!
//! To regenerate this file, follow these steps:
//! 1. Clone the `storage-hub` repo if you haven't already.
//! 2. Make sure you're able to run BSPNet integration tests locally. You can see the steps in the [testing README](https://github.com/Moonsong-Labs/storage-hub/blob/main/test/README.md).
//!     Usually this involves just:
//!     a. Building the node. Be careful to build with the `runtime-benchmarks` feature enabled. If you're building in a Mac for instance, run `pnpm crossbuild:mac --features runtime-benchmarks`.
//!     b. Building docker images. Run `pnpm docker:build`.
//! 3. Run the script with `pnpm docker:start:generateFileSystemBenchmarkProofs`.
//!
//! The `generateFileSystemBenchmarkProofs.ts` script should run, and it should automatically regenerate this file.

use shp_file_metadata::FileMetadata;
use sp_core::crypto::Ss58Codec;
use sp_runtime::AccountId32;
use alloc::{vec, vec::Vec};

#[rustfmt::skip]
pub fn get_msp_id() -> Vec<u8> {
    {{msp_id}}
}

#[rustfmt::skip]
pub fn get_bucket_id(bucket_index: u32) -> Vec<u8> {
	match bucket_index {
		{{bucket_id}}
		_ => panic!(
			"Bucket index ({}) is not supported",
			bucket_index
		),
	}
}

#[rustfmt::skip]
pub fn get_bucket_root(bucket_index: u32) -> Vec<u8> {
	match bucket_index {
		{{bucket_root}}
		_ => panic!(
			"Bucket index ({}) is not supported",
			bucket_index
		),
	}
}

#[rustfmt::skip]
pub fn get_user_account() -> AccountId32 {
	{{user_account}}
}

#[rustfmt::skip]
pub fn fetch_non_inclusion_proofs(number_of_file_keys_to_accept: u32, bucket_index: u32) -> Vec<u8> {
	let non_inclusion_proofs = match number_of_file_keys_to_accept {
		{{non_inclusion_proofs}}
		_ => panic!(
			"Number of file keys to accept ({}) is not supported",
			number_of_file_keys_to_accept
		),
	};

	non_inclusion_proofs[(bucket_index - 1) as usize].clone()
}

#[rustfmt::skip]
pub fn fetch_file_keys_to_accept(number_of_file_keys_to_accept: u32, bucket_index: u32) -> Vec<Vec<u8>> {
	let all_file_keys_to_accept = match number_of_file_keys_to_accept {
		{{file_keys_to_accept}}
		_ => panic!(
			"Number of file keys to accept ({}) is not supported",
			number_of_file_keys_to_accept
		),
	};

	// We only need to keep the file keys that correspond to the bucket. That is:
	// - If the bucket index is 1, we keep the first `number_of_file_keys_to_accept` file keys.
	// - If the bucket index is 2, we keep the second `number_of_file_keys_to_accept` file keys.
	// - Etc
	let start_index = ((bucket_index - 1) * number_of_file_keys_to_accept) as usize;
	let end_index = start_index + number_of_file_keys_to_accept as usize;
	all_file_keys_to_accept[start_index..end_index].to_vec()
}

#[rustfmt::skip]
pub fn fetch_file_key_proof(file_key_amount_per_bucket: u32, bucket_index: u32, file_key_index: u32) -> Vec<u8> {
	// Get all file key proofs for this case
	let file_key_proofs = match file_key_amount_per_bucket {
		{{file_key_proofs}}
		_ => panic!(
			"File key amount per bucket ({}) is not supported",
			file_key_amount_per_bucket
		),
	};

	// We only need to keep the file keys that correspond to the bucket. That is:
	// - If the bucket index is 1, we keep the first `number_of_file_keys_to_accept` file keys.
	// - If the bucket index is 2, we keep the second `number_of_file_keys_to_accept` file keys.
	// - Etc
	let start_index = ((bucket_index - 1) * file_key_amount_per_bucket) as usize;
	let end_index = start_index + file_key_amount_per_bucket as usize;
	let file_key_proofs_for_bucket = file_key_proofs[start_index..end_index].to_vec();

	// Get the file key proof we want
	file_key_proofs_for_bucket[file_key_index as usize].clone()
}

#[rustfmt::skip]
pub fn get_bsp_id() -> Vec<u8> {
    {{bsp_id}}
}

#[rustfmt::skip]
pub fn get_bsp_root() -> Vec<u8> {
    {{bsp_root}}
}

#[rustfmt::skip]
pub fn fetch_inclusion_proof() -> Vec<u8> {
	{{inclusion_proof}}
}

#[rustfmt::skip]
pub fn fetch_file_key_for_inclusion_proof() -> Vec<u8> {
	{{file_key_inclusion_proof}}
}

#[rustfmt::skip]
pub fn fetch_file_key_metadata_for_inclusion_proof() -> FileMetadata<{shp_constants::H_LENGTH}, {shp_constants::FILE_CHUNK_SIZE}, {shp_constants::FILE_SIZE_TO_CHALLENGES}> {
	FileMetadata::new(
		{{file_key_metadata_inclusion_proof_owner}},
		{{file_key_metadata_inclusion_proof_bucket_id}},
		{{file_key_metadata_inclusion_proof_location}},
		{{file_key_metadata_inclusion_proof_file_size}},
		{{file_key_metadata_inclusion_proof_fingerprint}}
	).unwrap()
}

#[rustfmt::skip]
pub fn fetch_file_keys_for_bsp_confirm(number_of_file_keys_to_confirm: u32) -> Vec<Vec<u8>> {
	match number_of_file_keys_to_confirm {
		{{file_keys_for_bsp_confirm}}
		_ => panic!(
			"Number of file keys to confirm ({}) is not supported",
			number_of_file_keys_to_confirm
		),
	}
}

#[rustfmt::skip]
pub fn fetch_file_key_proof_for_bsp_confirm(file_key_index: u32) -> Vec<u8> {
	match file_key_index {
		{{file_key_proofs_for_bsp_confirm}}
		_ => panic!(
			"File key index ({}) is not supported",
			file_key_index
		),
	}
}

#[rustfmt::skip]
pub fn fetch_bucket_inclusion_proofs(number_of_file_keys: u32, bucket_index: u32) -> Vec<u8> {
	let bucket_inclusion_proofs = match number_of_file_keys {
		{{bucket_inclusion_proofs}}
		_ => panic!(
			"Number of file keys ({}) is not supported",
			number_of_file_keys
		),
	};

	bucket_inclusion_proofs[(bucket_index - 1) as usize].clone()
}

#[rustfmt::skip]
pub fn fetch_bsp_inclusion_proofs(number_of_file_keys: u32) -> Vec<u8> {
	match number_of_file_keys {
		{{bsp_inclusion_proofs}}
		_ => panic!(
			"Number of file keys ({}) is not supported",
			number_of_file_keys
		),
	}
}

#[rustfmt::skip]
pub fn fetch_file_deletion_signatures(number_of_file_keys: u32, bucket_index: u32) -> Vec<Vec<u8>> {
	let all_signatures = match number_of_file_keys {
		{{file_deletion_signatures}}
		_ => panic!(
			"Number of file keys ({}) is not supported",
			number_of_file_keys
		),
	};

	// We only need to keep the signatures that correspond to the bucket. That is:
	// - If the bucket index is 1, we keep the first `number_of_file_keys` signatures.
	// - If the bucket index is 2, we keep the second `number_of_file_keys` signatures.
	// - Etc
	let start_index = ((bucket_index - 1) * number_of_file_keys) as usize;
	let end_index = start_index + number_of_file_keys as usize;
	all_signatures[start_index..end_index].to_vec()
}

#[rustfmt::skip]
pub fn fetch_file_metadata_for_deletion(number_of_file_keys: u32, bucket_index: u32, file_key_index: u32) -> (Vec<u8>, u64, Vec<u8>) {
	// Get all metadata tuples (location, size, fingerprint) for this case
	let all_metadata = match number_of_file_keys {
		{{file_metadata_for_deletion}}
		_ => panic!(
			"Number of file keys ({}) is not supported",
			number_of_file_keys
		),
	};

	// Extract metadata for the specific bucket
	// - If bucket_index is 1, we get metadata at indices [0..number_of_file_keys)
	// - If bucket_index is 2, we get metadata at indices [number_of_file_keys..2*number_of_file_keys)
	// - Etc
	let start_index = ((bucket_index - 1) * number_of_file_keys) as usize;
	let metadata_index = start_index + file_key_index as usize;
	
	all_metadata[metadata_index].clone()
}
