use crate::types::{Bucket, MainStorageProvider};
use codec::Encode;
use frame_support::ensure;
use frame_support::pallet_prelude::DispatchResult;
use frame_support::sp_runtime::{
    traits::{CheckedAdd, Hash, One},
    ArithmeticError, DispatchError,
};
use frame_support::traits::{
    fungible::{Inspect, InspectHold, MutateHold},
    tokens::{Fortitude, Preservation},
    Get,
};
use storage_hub_traits::ProvidersInterface;

use multiaddr::Multiaddr;

use crate::*;

impl<T> Pallet<T>
where
    T: pallet::Config,
{
    pub fn do_msp_sign_up(who: &T::AccountId, msp_info: &MainStorageProvider<T>) -> DispatchResult {
        // todo!("If this comment is present, it means this function is still incomplete even though it compiles.")

        // Check that, by registering this Main Storage Provider, we are not exceeding the maximum number of Main Storage Providers
        let new_amount_of_msps = MspCount::<T>::get()
            .checked_add(&T::SpCount::one())
            .ok_or(DispatchError::Arithmetic(ArithmeticError::Overflow))?;
        ensure!(
            new_amount_of_msps <= T::MaxMsps::get(),
            Error::<T>::MaxMspsReached
        );

        // Check that the account is not already registered either as a Main Storage Provider or a Backup Storage Provider
        ensure!(
            AccountIdToMainStorageProviderId::<T>::get(who).is_none()
                && AccountIdToBackupStorageProviderId::<T>::get(who).is_none(),
            Error::<T>::AlreadyRegistered
        );

        // Check that the multiaddresses vector is not empty (SPs have to register with at least one)
        ensure!(
            !msp_info.multiaddresses.is_empty(),
            Error::<T>::NoMultiAddress
        );

        // Check that the multiaddresses are valid
        for multiaddress in msp_info.multiaddresses.iter() {
            let multiaddress_vec = multiaddress.to_vec();
            let valid_multiaddress = Multiaddr::try_from(multiaddress_vec);
            match valid_multiaddress {
                Ok(_) => (),
                Err(_) => return Err(Error::<T>::InvalidMultiAddress.into()),
            }
        }

        // Check that the data to be stored is bigger than the minimum required by the runtime
        ensure!(
            msp_info.capacity >= T::SpMinCapacity::get(),
            Error::<T>::StorageTooLow
        );

        // TODO: Any value proposition checks?

        // Calculate how much deposit will the signer have to pay to register with this amount of data
        let deposit = T::SpMinDeposit::get()
            + T::DepositPerData::get() * (msp_info.capacity - T::SpMinCapacity::get()).into();
        // Check if the user has enough balance to pay the deposit
        let user_balance =
            T::NativeBalance::reducible_balance(who, Preservation::Preserve, Fortitude::Polite);
        ensure!(user_balance >= deposit, Error::<T>::NotEnoughBalance);
        // Check if we can hold the deposit from the user
        ensure!(
            T::NativeBalance::can_hold(&HoldReason::StorageProviderDeposit.into(), who, deposit),
            // TODO: Change this error to something more descriptive
            Error::<T>::NotEnoughBalance
        );
        // Hold the deposit from the user
        T::NativeBalance::hold(&HoldReason::StorageProviderDeposit.into(), who, deposit)?;

        // TODO:
        // We then get the MainStorageProviderId by using the AccountId as the seed for a random generator
        // let (msp_id, block_number_when_random) =
        //    T::ProvidersRandomness::random(who.encode().as_ref());
        // And we should check that the block number when this randomness is valid is bigger than the current one
        // TODO: implement this check and, if not valid, save somehow the randomness and the account id to retry later, probably in a queue

        // Temporary, replace with random salt generated by a VRF (pseudocode above)
        let msp_id: MainStorageProviderId<T> =
            <T as pallet::Config>::Hashing::hash(who.encode().as_ref());

        // We then insert the MainStorageProviderId into the mapping
        AccountIdToMainStorageProviderId::<T>::insert(who, msp_id);

        // After that, we save the MainStorageProvider information in storage
        MainStorageProviders::<T>::insert(&msp_id, msp_info);

        // And we increment the counter of Main Storage Providers registered
        MspCount::<T>::mutate(|n| {
            let new_amount_of_msps = n.checked_add(&T::SpCount::one());
            match new_amount_of_msps {
                Some(new_amount_of_msps) => {
                    *n = new_amount_of_msps;
                    Ok(())
                }
                None => Err(DispatchError::Arithmetic(ArithmeticError::Overflow)),
            }
        })
    }

    pub fn do_bsp_sign_up(
        who: &T::AccountId,
        bsp_info: BackupStorageProvider<T>,
    ) -> DispatchResult {
        // todo!("If this comment is present, it means this function is still incomplete even though it compiles.")

        // Check that, by registering this Backup Storage Provider, we are not exceeding the maximum number of Backup Storage Providers
        let new_amount_of_bsps = BspCount::<T>::get()
            .checked_add(&T::SpCount::one())
            .ok_or(DispatchError::Arithmetic(ArithmeticError::Overflow))?;
        ensure!(
            new_amount_of_bsps <= T::MaxBsps::get(),
            Error::<T>::MaxBspsReached
        );

        // Check that the account is not already registered either as a Main Storage Provider or a Backup Storage Provider
        ensure!(
            AccountIdToMainStorageProviderId::<T>::get(who).is_none()
                && AccountIdToBackupStorageProviderId::<T>::get(who).is_none(),
            Error::<T>::AlreadyRegistered
        );

        // Check that the multiaddresses vector is not empty (SPs have to register with at least one)
        ensure!(
            !bsp_info.multiaddresses.is_empty(),
            Error::<T>::NoMultiAddress
        );

        // Check that the multiaddresses are valid
        for multiaddress in bsp_info.multiaddresses.iter() {
            let multiaddress_vec = multiaddress.to_vec();
            let valid_multiaddress = Multiaddr::try_from(multiaddress_vec);
            match valid_multiaddress {
                Ok(_) => (),
                Err(_) => return Err(Error::<T>::InvalidMultiAddress.into()),
            }
        }

        // Check that the data to be stored is bigger than the minimum required by the runtime
        ensure!(
            bsp_info.capacity >= T::SpMinCapacity::get(),
            Error::<T>::StorageTooLow
        );

        // Calculate how much deposit will the signer have to pay to register with this amount of data
        let deposit = T::SpMinDeposit::get()
            + T::DepositPerData::get() * (bsp_info.capacity - T::SpMinCapacity::get()).into();
        // Check if the user has enough balance to pay the deposit
        let user_balance =
            T::NativeBalance::reducible_balance(who, Preservation::Preserve, Fortitude::Polite);
        ensure!(user_balance >= deposit, Error::<T>::NotEnoughBalance);
        // Check if we can hold the deposit from the user
        ensure!(
            T::NativeBalance::can_hold(&HoldReason::StorageProviderDeposit.into(), who, deposit),
            // TODO: Change this error to something more descriptive
            Error::<T>::NotEnoughBalance
        );
        // Hold the deposit from the user
        T::NativeBalance::hold(&HoldReason::StorageProviderDeposit.into(), who, deposit)?;

        // TODO:
        // We then get the BainStorageProviderId by using the AccountId as the seed for a random generator
        // let (bsp_id, block_number_when_random) =
        //    T::ProvidersRandomness::random(who.encode().as_ref());
        // And we should check that the block number when this randomness is valid is bigger than the current one
        // TODO: implement this check and, if not valid, save somehow the randomness and the account id to retry later, probably in a queue

        // Temporary, replace with random salt generated by a VRF (pseudocode above)
        let bsp_id: BackupStorageProviderId<T> =
            <T as pallet::Config>::Hashing::hash(who.encode().as_ref());

        // We then insert the BackupStorageProviderId into the mapping
        AccountIdToBackupStorageProviderId::<T>::insert(who, bsp_id);

        // After that, we save the BackupStorageProvider information in storage
        BackupStorageProviders::<T>::insert(&bsp_id, bsp_info.clone());

        // We increment the total capacity of the network (which is the sum of all BSPs capacities)
        TotalBspsCapacity::<T>::mutate(|n| {
            let new_total_bsp_capacity = n.checked_add(&bsp_info.capacity);
            match new_total_bsp_capacity {
                Some(new_total_bsp_capacity) => {
                    *n = new_total_bsp_capacity;
                    Ok(())
                }
                None => Err(DispatchError::Arithmetic(ArithmeticError::Overflow)),
            }
        })?;

        // And we increment the counter of Backup Storage Providers registered
        // To keep in mind: we check that the new amount of bsps is valid at the start of this function,
        // but just in case we check it again here (we could have used expect)
        BspCount::<T>::mutate(|n| {
            let new_amount_of_bsps = n.checked_add(&T::SpCount::one());
            match new_amount_of_bsps {
                Some(new_amount_of_bsps) => {
                    *n = new_amount_of_bsps;
                    Ok(())
                }
                None => Err(DispatchError::Arithmetic(ArithmeticError::Overflow)),
            }
        })
    }

    pub fn do_msp_sign_off(_who: &T::AccountId) -> DispatchResult {
        todo!()
    }

    pub fn do_bsp_sign_off(_who: &T::AccountId) -> DispatchResult {
        todo!()
    }
}

impl<T: Config> From<MainStorageProvider<T>> for BackupStorageProvider<T> {
    fn from(msp: MainStorageProvider<T>) -> Self {
        BackupStorageProvider {
            capacity: msp.capacity,
            data_used: msp.data_used,
            multiaddresses: msp.multiaddresses,
            root: MerklePatriciaRoot::<T>::default(),
        }
    }
}

/// Implement the StorageProvidersInterface trait for the Storage Providers pallet.
impl<T: pallet::Config> StorageProvidersInterface<T> for pallet::Pallet<T> {
    fn change_data_used(who: &T::AccountId, data_change: T::StorageData) -> DispatchResult {
        // TODO: refine this logic, add checks
        if let Some(msp_id) = AccountIdToMainStorageProviderId::<T>::get(who) {
            let mut msp =
                MainStorageProviders::<T>::get(&msp_id).ok_or(Error::<T>::NotRegistered)?;
            msp.data_used += data_change;
            MainStorageProviders::<T>::insert(&msp_id, msp);
        } else if let Some(bsp_id) = AccountIdToBackupStorageProviderId::<T>::get(who) {
            let mut bsp =
                BackupStorageProviders::<T>::get(&bsp_id).ok_or(Error::<T>::NotRegistered)?;
            bsp.data_used += data_change;
            BackupStorageProviders::<T>::insert(&bsp_id, bsp);
        } else {
            return Err(Error::<T>::NotRegistered.into());
        }
        Ok(())
    }

    // Bucket specific functions:
    fn add_bucket(
        msp_id: MainStorageProviderId<T>,
        user_id: T::AccountId,
        bucket_id: BucketId<T>,
        bucket_root: MerklePatriciaRoot<T>,
    ) -> DispatchResult {
        // TODO: Check that the bucket does not exist yet
        // TODO: Get BucketId by hashing Bucket with salt, add it to the MSP vector of buckets
        let bucket = Bucket {
            root: bucket_root,
            user_id,
            msp_id,
        };
        Buckets::<T>::insert(&bucket_id, &bucket);
        Ok(())
    }

    fn change_root_bucket(
        bucket_id: BucketId<T>,
        new_root: MerklePatriciaRoot<T>,
    ) -> DispatchResult {
        if let Some(bucket) = Buckets::<T>::get(&bucket_id) {
            Buckets::<T>::insert(
                &bucket_id,
                Bucket {
                    root: new_root,
                    ..bucket
                },
            );
        } else {
            return Err(Error::<T>::NotRegistered.into());
        }
        Ok(())
    }

    fn remove_root_bucket(bucket_id: BucketId<T>) -> DispatchResult {
        Buckets::<T>::remove(&bucket_id);
        Ok(())
    }

    // BSP specific functions:
    fn change_root_bsp(
        who: BackupStorageProviderId<T>,
        new_root: MerklePatriciaRoot<T>,
    ) -> DispatchResult {
        if let Some(b) = BackupStorageProviders::<T>::get(&who) {
            BackupStorageProviders::<T>::insert(
                who,
                BackupStorageProvider {
                    root: new_root,
                    ..b
                },
            );
        } else {
            return Err(Error::<T>::NotRegistered.into());
        }
        Ok(())
    }

    fn remove_root_bsp(who: &<T>::AccountId) -> DispatchResult {
        let bsp_id =
            AccountIdToBackupStorageProviderId::<T>::get(who).ok_or(Error::<T>::NotRegistered)?;
        BackupStorageProviders::<T>::remove(&bsp_id);
        AccountIdToBackupStorageProviderId::<T>::remove(&who);
        Ok(())
    }
}

impl<T: pallet::Config> ProvidersInterface for pallet::Pallet<T> {
    type AccountId = T::AccountId;
    type Provider = HashId<T>;
    type Balance = T::NativeBalance;
    type MerkleHash = MerklePatriciaRoot<T>;

    // TODO: Refine, add checks and tests for all the logic in this implementation

    fn is_provider(who: Self::Provider) -> bool {
        BackupStorageProviders::<T>::contains_key(&who)
            || MainStorageProviders::<T>::contains_key(&who)
            || Buckets::<T>::contains_key(&who)
    }

    fn get_provider(who: Self::AccountId) -> Option<Self::Provider> {
        if let Some(bsp_id) = AccountIdToBackupStorageProviderId::<T>::get(&who) {
            Some(bsp_id)
        } else if let Some(msp_id) = AccountIdToMainStorageProviderId::<T>::get(&who) {
            Some(msp_id)
        } else {
            None
        }
    }

    fn get_root(who: Self::Provider) -> Option<Self::MerkleHash> {
        if let Some(bucket) = Buckets::<T>::get(&who) {
            Some(bucket.root)
        } else if let Some(bsp) = BackupStorageProviders::<T>::get(&who) {
            Some(bsp.root)
        } else {
            None
        }
    }

    fn get_stake(who: Self::Provider) -> Option<BalanceOf<T>> {
        // TODO: This is not the stake, this logic will be done later down the line
        if let Some(bucket) = Buckets::<T>::get(&who) {
            let _related_msp = MainStorageProviders::<T>::get(bucket.msp_id);
            Some(T::SpMinDeposit::get())
        } else if let Some(_bsp) = BackupStorageProviders::<T>::get(&who) {
            Some(T::SpMinDeposit::get())
        } else {
            None
        }
    }
}
