use jsonrpsee::core::async_trait;
use jsonrpsee::core::RpcResult;
use jsonrpsee::proc_macros::rpc;
use jsonrpsee::types::error::ErrorObjectOwned as JsonRpseeError;
use jsonrpsee::types::error::INTERNAL_ERROR_CODE;
use jsonrpsee::types::error::INTERNAL_ERROR_MSG;
use jsonrpsee::types::ErrorObjectOwned;

use shc_common::types::FileMetadata;
use shc_common::types::FILE_CHUNK_SIZE;
use sp_runtime::AccountId32;


use sp_trie::TrieLayout;


use file_manager::traits::FileDataTrie;
use file_manager::traits::FileStorage;

use log::debug;
use log::error;

use std::fmt::Debug;
use std::fs::File;
use std::io::Read;
use std::marker::PhantomData;
use std::path::PathBuf;
use std::sync::Arc;

use tokio::sync::RwLock;

const LOG_TARGET: &str = "file-storage-rpc";

/// Provides an interface with the desired RPC method.
/// Used by the `rpc` macro from `jsonrpsee`
/// to generate the trait that is actually going to be implemented.
#[rpc(server, namespace = "filestorage")]
#[async_trait]
pub trait FileStorageApi {
    #[method(name = "uploadFile")]
    async fn upload_file(
        &self,
        file_path: String,
        location: String,
        owner: AccountId32,
    ) -> RpcResult<FileMetadata>;
}

/// Stores the required objects to be used in our RPC method.
pub struct FileStorageRpc<FL, T> {
    file_storage: Arc<RwLock<FL>>,
    _marker: PhantomData<T>,
}

impl<FL, T> FileStorageRpc<FL, T> {
    pub fn new(file_storage: Arc<RwLock<FL>>) -> Self {
        Self {
            file_storage,
            _marker: Default::default(),
        }
    }
}

/// Interface generated by the `rpc` macro from our `FileStorageApi` trait.
#[async_trait]
impl<FL, T> FileStorageApiServer for FileStorageRpc<FL, T>
where
    FL: Send + Sync + FileStorage<T>,
    T: Send + Sync + TrieLayout + 'static,
{
    async fn upload_file(
        &self,
        file_path: String,
        location: String,
        owner: AccountId32,
    ) -> RpcResult<FileMetadata> {
        let mut file = File::open(PathBuf::from(file_path.clone())).map_err(into_rpc_error)?;
        let mut file_chunks = Vec::new();

        // Read file in chunks of [`FILE_CHUNK_SIZE`] into buffer then push buffer into a vector.
        // Loops until EOF or until some error that is NOT `ErrorKind::Interrupted` is found.
        // If `ErrorKind::Interrupted` is found, the operation is simply retried, as per
        // https://doc.rust-lang.org/std/io/trait.Read.html#errors-1
        loop {
            let mut buffer = Vec::with_capacity(FILE_CHUNK_SIZE);
            let read_result = file
                .by_ref()
                .take(FILE_CHUNK_SIZE as u64)
                .read_to_end(&mut buffer);
            match read_result {
                // Reached EOF, break loop.
                Ok(0) => {
                    debug!(target: LOG_TARGET, "Finished reading file");
                    break;
                }
                // Haven't reached EOF yet, continue loop.
                Ok(bytes_read) => {
                    debug!(target: LOG_TARGET, "Read {} bytes from file", bytes_read);
                    file_chunks.push(buffer)
                }
                Err(e) => {
                    error!(target: LOG_TARGET, "Error when trying to read file: {:?}", e);
                    return Err(into_rpc_error(e));
                }
            }
        }

        // Build the [`FileDataTrie`] by writing the file chunks into it.
        let mut file_data_trie = <FL as FileStorage<T>>::FileDataTrie::default();
        for (chunk_id, chunk) in file_chunks.iter().enumerate() {
            let chunk_id = chunk_id as u64;
            file_data_trie
                .write_chunk(&chunk_id, chunk)
                .map_err(into_rpc_error)?;
        }
        // Generate the necessary metadata so we can insert file into the File Storage.
        let root = file_data_trie.get_root();
        let fs_metadata = file.metadata().map_err(into_rpc_error)?;
        let file_size = fs_metadata.len();
        let file_metadata = FileMetadata {
            size: file_size,
            fingerprint: root.as_ref().into(),
            owner: owner.to_string(),
            location: location.clone().into(),
        };
        let file_key = file_metadata.key::<T::Hash>();

        // Acquire FileStorage write lock.
        let mut file_storage_lock = self.file_storage.write().await;

        // Finally Store file into File Storage.
        file_storage_lock
            .insert_file_with_data(file_key, file_metadata.clone(), file_data_trie)
            .map_err(into_rpc_error)?;

        Ok(file_metadata)
    }
}

/// Converts into the expected kind of error for `jsonrpsee`'s `RpcResult<_>`.
fn into_rpc_error(e: impl Debug) -> JsonRpseeError {
    ErrorObjectOwned::owned(
        INTERNAL_ERROR_CODE,
        INTERNAL_ERROR_MSG,
        Some(format!("{:?}", e)),
    )
}
